options{  JDK_VERSION = "1.6";  JAVA_UNICODE_ESCAPE = true;}PARSER_BEGIN(SizzleParser)package sizzle.parser;public class SizzleParser{}PARSER_END(SizzleParser)SKIP : /* WHITE SPACE */{  " "| "\t"| "\n"| "\r"| "\f"}SPECIAL_TOKEN : /* COMMENTS */{  < SINGLE_LINE_COMMENT :    "#" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >//|  < PROTO_STATEMENT ://    "proto" (~[ "\n", "\r" ])*//    (//      "\n"//    | "\r"//    | "\r\n"//    ) >  { if (java.lang.System.currentTimeMillis() > 0) throw new java.lang.RuntimeException(matchedToken.toString().substring(7).replace("\"", "")); }| < INCLUDE_STATEMENT :    "include" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) > }TOKEN :{  < DOLLAR : "$" >| < OF : "of" >| < IF : "if" >| < DO : "do" >| < OR : "or" >| < AND : "and" >| < ALL : "all" >| < MAP : "map" >| < FOR : "for" >| < NOT : "not" >| < TYPE : "type" >| < PROC : "proc" >| < FILE : "file" >| < ELSE : "else" >| < CASE : "case" >| < SOME : "some" >| < EACH : "each" >| < WHEN : "when" >| < SKIP_ : "skip" >| < EMIT : "emit" >| < REST : "rest" >| < TABLE : "table" >| < WHILE : "while" >| < BREAK : "break" >| < PROTO : "proto" >| < PROTOX : "protox" >| < ARRAY : "array" >| < STATIC : "static" >| < SWITCH : "switch" >| < RETURN : "return" >| < WEIGHT : "weight" >| < FORMAT : "format" >| < RESULT : "result" >| < DEFAULT_ : "default" >| < CONTINUE : "continue" >| < SUBMATCH : "submatch" >| < FUNCTION : "function" >| < PARSEDMESSAGE : "parsedmessage" >}TOKEN : /* LITERALS */{  < INTEGER_LITERAL :    < BINARY_LITERAL >  | < OCTAL_LITERAL >  | < DECIMAL_LITERAL >  | < HEX_LITERAL > >| < #BINARY_LITERAL : "0" [ "b", "B" ] ([ "0"-"1" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] (< HEX_DIGIT_LITERAL >)+ >| < FLOATING_POINT_LITERAL :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)? ([ "f", "F", "d", "D" ])?  | "." ([ "0"-"9" ])+ (< EXPONENT >)? ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ < EXPONENT > ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ (< EXPONENT >)? [ "f", "F", "d", "D" ] >| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < CHARACTER_LITERAL :    "'"    (      (~[ "'", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )    "'" >| < STRING_LITERAL :    "\""    (      (~[ "\"", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )*    "\"" >| < HEX_DIGIT_LITERAL : [ "0"-"9", "a"-"f", "A"-"F" ] >| < FINGERPRINT_LITERAL : < INTEGER_LITERAL > [ "p", "P" ] >| < BYTES_LITERAL :    "B" < STRING_LITERAL >  | "X" "\"" ( < HEX_DIGIT_LITERAL > < HEX_DIGIT_LITERAL > )* "\"" >| < TIME_LITERAL :    < INTEGER_LITERAL > [ "t", "T" ]  | "T" < STRING_LITERAL > >}// Cribbed from the Java 1.1 grammar
TOKEN : /* IDENTIFIERS */{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "\u0024", "\u0041"-"\u005a", "\u005f", "\u0061"-"\u007a", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff" ] >| < #DIGIT : [ "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049" ] >}void Start() :{}{  Program() < EOF >}// Program = { Declaration | Statement }.void Program() :{}{  (    LOOKAHEAD(Declaration())    Declaration()  | Statement()  | Proto()  )+}// Declaration = TypeDecl | StaticVarDecl | VarDecl.void Declaration() :{}{  TypeDecl()| StaticVarDecl()| VarDecl()}// TypeDecl = 'type' type_name '=' Type ';'.// type_name = identifier.void TypeDecl() :{}{  "type" Identifier() "=" Type() ";"}// StaticVarDecl = 'static' VarDecl.void StaticVarDecl() :{}{  "static" VarDecl()}// VarDecl = var_name ':' [Type] ['=' Expression | Block] ';'.// var_name = identifier.void VarDecl() :{}{  Identifier() ":"  [    LOOKAHEAD(Type())    Type()  ]  [ "=" Expression() | Block() ] ";"}// Type =//   type_name | ArrayType | MapType | TupleType |//   OutputType | FunctionType | 'proto' Type.// type_name = identifier.void Type() :{}{  Identifier()| ArrayType()| MapType()| TupleType()| OutputType()| FunctionType()| "protox" Type()}// Component = [component_name ':'] ComponentType.// component_name = identifier.// ComponentType = Type.void Component() :{}{  [    LOOKAHEAD(Identifier() ":")    Identifier() ":"  ]  Type()}// ArrayType = 'array' 'of' Element.// Element = Component.void ArrayType() :{}{  "array" "of" Component()}// TupleType = SimpleTupleType | ProtoTupleType.void TupleType() :{}{  LOOKAHEAD(SimpleTupleType())  SimpleTupleType()| ProtoTupleType()}// SimpleTupleType = '{' [SimpleMemberList] '}'.void SimpleTupleType() :{}{	"{" [ SimpleMemberList() ] "}"}// SimpleMemberList = SimpleMember {',' SimpleMember} [','].void SimpleMemberList() :{}{  SimpleMember()  (    LOOKAHEAD("," SimpleMember())    "," SimpleMember()  )*  [","]}// SimpleMember = TypeDecl | StaticVarDecl | SimpleFieldDecl.// SimpleFieldDecl = Component.void SimpleMember() :{}{  TypeDecl()| StaticVarDecl()| Component()}// ProtoTupleType = ['parsedmessage'] '{' [ProtoMemberList] '}'.void ProtoTupleType() :{}{  [ "parsedmessage" ] "{" [ ProtoMemberList() ] "}"}// ProtoMemberList = ProtoMember {',' ProtoMember} [','].void ProtoMemberList() :{}{  ProtoMember()  (    LOOKAHEAD("," ProtoMember())    "," ProtoMember()  )*  [","]}// ProtoMember = TypeDecl | StaticVarDecl | ProtoFieldDecl.void ProtoMember() :{}{  TypeDecl()| StaticVarDecl()| ProtoFieldDecl()}// ProtoFieldDecl = Component ['=' ProtoFieldDefault] '@' proto_field_tag [':' proto_field_type].// ProtoFieldDefault = Expression.// proto_field_tag = integer.// proto_field_type = identifier.void ProtoFieldDecl() :{}{  Component() [ "=" Expression() ] "@" Identifier() [ ":" Identifier() ]}// MapType = 'map' '[' Key ']' 'of' Value.// Key = Component.// Value = Component.void MapType() :{}{  "map" "[" Component() "]" "of" Component()}// OutputType =//   'table' table_type [Parameter] {Index} 'of' Element [Weight]//   [FileSpec | ProcSpec ] [FormatSpec].// table_type = identifier.// Parameter = '(' Expression ')'.// Index = '[' Component ']'.// Element = Component.// Weight = 'weight' Component.// FileSpec = 'file' '(' ArgumentList ')'.// ProcSpec = 'proc' '(' ArgumentList ')'.// FormatSpec = 'format' '(' ArgumentList ')'.// ArgumentList = ExprList.void OutputType() :{}{  "table" Identifier() [ "(" ExprList() ")" ]  (    "[" Component() "]"  )*  "of" Component()  [    LOOKAHEAD("weight" Component())    "weight" Component()  ]  [    "file" "(" ExprList() ")"   | "proc" "(" ExprList() ")"  ]  [ "format" "(" ExprList() ")" ]}// ExprList = Expression {',' Expression }.void ExprList() :{}{  Expression()  (    "," Expression()  )*}// FunctionType = 'function' '(' [ParameterList] ')' [ResultSpec].// ParameterList = Parameter {',' Parameter}.// Parameter = identifier ':' Type.// ResultSpec = ':' Type.void FunctionType() :{}{  "function" "(" [    Identifier() ":" Type()    (      "," Identifier() ":" Type()    )*  ] ")"  [ ":" Type() ]}// Statement =//   Assignment | Block | BreakStatement | ContinueStatement | DoStatement |//   EmitStatement | ExprStatement | ForStatement | IfStatement | ResultStatement |//   ReturnStatement | SwitchStatement | WhenStatement | WhileStatement.void Statement() :{}{  LOOKAHEAD(Assignment())  Assignment()| LOOKAHEAD(Block())  Block()| BreakStatement()| ContinueStatement()| DoStatement()| EmitStatement()| ExprStatement()| ForStatement()| IfStatement()| ResultStatement()| ReturnStatement()| SwitchStatement()| WhenStatement()| WhileStatement()}// Assignment = Factor '=' Expression ';'void Assignment() :{}{  Factor() "=" Expression() ";"}// Block = '{' { Declaration | Statement } '}'.void Block() :{}{  "{"  (    LOOKAHEAD(Declaration())    Declaration()  | Statement()  )*  "}"}// BreakStatement = 'break'.void BreakStatement() :{}{  "break"}// ContinueStatement = 'continue'.void ContinueStatement() :{}{  "continue"}// DoStatement = 'do' Statement 'while' '(' Expression ')' ';'.void DoStatement() :{}{  "do" Statement() "while" "(" Expression() ")" ";"}// EmitStatement = 'emit' OutputDesignator '<-' Expression ['weight' Expression] ';'.// OutputDesignator = var_name {'[' Expression ']'}.void EmitStatement() :{}{  "emit" Identifier() (    "[" Expression() "]"  )* "<-" Expression() [ "weight" Expression() ] ";"}// ExprStatement = Expression [ '++' | '--' ] ';'.void ExprStatement() :{}{  Expression() [ "++" | "--" ] ";"}// ForStatement =//   'for' '(' [ForDeclExpr] ';' [Expression] ';' [ForDeclExpr] ')' Statement.// ForDeclExpr = Declaration | ExprStatement.void ForStatement() :{}{  "for" "("   [    LOOKAHEAD(Declaration())    Declaration()  | ExprStatement()  ]  ";"  [ Expression() ] ";"  [    LOOKAHEAD(Declaration())    Declaration()  | ExprStatement()  ]  ")"  Statement()}// IfStatement = 'if' '(' Expression ')' Statement ['else' Statement].void IfStatement() :/* * The disambiguating algorithm of JavaCC automatically binds dangling * else's to the innermost if statement.  The LOOKAHEAD specification * is to tell JavaCC that we know what we are doing. */{}{  "if" "(" Expression() ")" Statement()  [    LOOKAHEAD(1)    "else" Statement()  ]}// ResultStatement = 'result' Expression.void ResultStatement() :{}{  "result" Expression()}// ReturnStatement = 'return' [ Expression ].void ReturnStatement() :{}{  "return" [ Expression() ] ";"}// SwitchStatement = 'switch' '(' Expression ')' '{' { Case } Default '}'.// Case = 'case' CaseLabelList ':' StatementList.// CaseLabelList = Expression {',' Expression}.// StatementList = Statement { Statement }.// Default = 'default' ':' StatementList.void SwitchStatement() :{}{  "switch" "(" Expression() ")" "{"  (    "case" Expression()    (      "," Expression()    )*    ":" Statement()    (      Statement()    )*  )*  "default" ":" Statement()  (    Statement()  )* "}"}// WhenStatement = 'when' '(' {QuantifierDecl} Expression ')' Statement.// QuantifierDecl = var_name ':' quantifier Type ';'.// quantifier = 'all' | 'each' | 'some'.void WhenStatement() :{}{  "when" "("  (    LOOKAHEAD(IdentifierList() ":")    IdentifierList() ":"    (      "all"    | "each"    | "some"    )    Type() ";"  )*  Expression() ")" Statement()}// nonstandard but necessary for a program in "Interpreting the Data"void IdentifierList() :{}{  Identifier()  (    "," Identifier()  )*}// WhileStatement = 'while' '(' Expression ')' Statement.void WhileStatement() :{}{  "while" "(" Expression() ")" Statement()}// Expression = Conjunction {('||' | 'or') Conjunction}.void Expression() :{}{  Conjunction()  (    (      "||"    | "or"    )    Conjunction()  )*}// Conjunction = Comparison {('&&' | 'and') Comparison}.void Conjunction() :{}{  Comparison()  (    (      "&&"    | "and"    )    Comparison()  )*}// Comparison = SimpleExpr [relation SimpleExpr].// relation = '==' | '!=' | '<' | '<=' | '>' | '>='.void Comparison() :{}{  SimpleExpr()  [    (      "=="    | "!="    | "<"    | "<="    | ">"    | ">="    )    SimpleExpr()  ]}// SimpleExpr = Term {add_operator Term}.// add_operator = '+' | '-' | '|' | '^'.void SimpleExpr() :{}{  Term()  (    (      "+"    | "-"    | "|"    | "^"    )    Term()  )*}// Term = Factor {mul_operator Factor}.// mul_operator = '*' | '/' | '%' | '<<' | '>>' | '&'.void Term() :{}{  Factor()  (    (      "*"    | "/"    | "%"    | "<<"    | ">>"    | "&"    )    Factor()  )*}// Factor = Operand { Selector | Index | Call | SawCall }.void Factor() :{}{  Operand()  (    Selector()  | Index()  | Call()//  | SawCall()  )*}// Selector = '.' field_name.// field_name = identifier.void Selector() :{}{  "." Identifier()}// Index = '[' Expression [':' Expression] ']'.void Index() :{}{  "[" Expression() [ ":" Expression() ] "]"}// Call = '(' ArgumentList ')'.void Call() :{}{  "(" [ ExprList() ] ")"}// SawCall =//   '(' [IterationCount ','] InputString//   ',' RegexpList [',' 'rest' Factor] ')'.// IterationCount = Expression.// InputString = Expression.// saw_name = identifier.???//void SawCall() ://{}//{//  "(" [ Expression() "," ] Expression() "," RegexpList() [ "," "rest" Factor() ] ")"//}// RegexpList = Regexp {',' Regexp}.void RegexpList() :{}{  Regexp()  (    LOOKAHEAD("," Regexp())    "," Regexp()  )*}// Regexp = ['skip'] ['submatch'] string.void Regexp() :{}{  [ "skip" ] [ "submatch" ] StringLiteral() }// Operand =//   identifier | literal | Composite | Function | unary_operator Factor |//   '$' | StatementExpr | '(' Expression ')'.// unary_operator = '+' | '-' | '~' | '!' | 'not'.void Operand() :{}{  LOOKAHEAD(Identifier())  Identifier()| StringLiteral()| IntegerLiteral()| FloatingPointLiteral()| LOOKAHEAD(Composite())  Composite()| Function()| (    "+"  | "-"  | "~"  | "!"  | "not"  )  Factor()| "$"| StatementExpr()| "(" Expression() ")"}// Composite = '{' [ExprList | PairList | ':'] '}'.void Composite() :{}{ "{"    [      LOOKAHEAD(Pair())      PairList()    | ExprList()    | ":"    ] "}"}// PairList = Pair {',' Pair}.void PairList() :{}{  Pair()  (    "," Pair()  )*}// Pair = Expression ':' Expression.void Pair() :{}{  Expression() ":" Expression()}// Function = Type Block.void Function() :{}{  Type() Block()}// StatementExpr = '?' Block .void StatementExpr() :{}{  "?" Block()}// Include = 'include' file_name.// file_name = string.//void Include() ://{}//{//  "include" StringLiteral()//}// Proto = 'proto' file_name.// file_name = string.void Proto() :{}{  "proto" StringLiteral()}// identifier = (letter | '_') {letter | '_' | digit}.// letter = 'A' .. 'Z' | 'a' .. 'z'.// digit = '0' .. '9'.void Identifier() :{}{  < IDENTIFIER >}// integer = ['-'] (binary_int | octal_int | decimal_int | hexadecimal_int).// binary_int = '0' ('B' | 'b') bin_digit {bin_digit}.// octal_int = '0' oct_digit {oct_digit}.// decimal_int = dec_digit {dec_digit}.// hexadecimal_int = '0' ('X' | 'x') hex_digit {hex_digit}.// bin_digit = '0' .. '1'.// oct_digit = '0' .. '7'.// dec_digit = '0' .. '9'.// hex_digit = '0' .. '9' | 'A' .. 'F' | 'a' .. 'f'.void IntegerLiteral() :{}{  < INTEGER_LITERAL >}// fingerprint = integer ('P' | 'p').void FingerprintLiteral() :{}{  < FINGERPRINT_LITERAL >}// floating_point = ['-'] [integer_part]['.' [fraction_part]] [scale_factor].// // integer_part = decimal_int.// fraction_part = decimal_int.// scale_factor = ('E' | 'e') ['+'|'-'] exponent.// exponent = decimal_int.void FloatingPointLiteral() :{}{  < FLOATING_POINT_LITERAL >}// char = ''' character '''.// character = ordinary_character | escaped_character.// escaped_character =//   '\' oct_digit [oct_digit [oct_digit]] |//   '\' 'x' hex_digit {hex_digit} |//   '\' 'u' hex_digit hex_digit hex_digit hex_digit |//   '\' 'U' hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit |//   '\' ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' | '"') |//   '\' ordinary_character.void CharLiteral() :{}{  < CHARACTER_LITERAL >}// string = '"' {character} '"' | '`' {character} '`'.void StringLiteral() :{}{  < STRING_LITERAL >}// bytes = 'B' string | 'X' hex_string.// hex_string = '"' { hex_digit hex_digit } '"' .void BytesLiteral() : {}{  < BYTES_LITERAL >}// time = integer ('T' | 't') | 'T' string.void TimeLiteral() :{}{  < TIME_LITERAL >}